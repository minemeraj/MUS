\numberwithin{equation}{section}
\numberwithin{table}{section}
\section{Preliminaries}
\label{sec:preliminaries}
\subsection{CNF}
A formula is said to be in CNF if and only if it is a conjunction of clauses adn a clause is a disjunction of literals. A literal could be a positive or negative instance of Boolean variable. A CNF formula $\varphi$ is defined as follows,
$$page 3$$
here, $C_{i}$ is the $i^{\text th}$ clause and $n$ is the number of total clauses in $\varphi$, $a_{ij}$ is the literal and $m$ is the total number of literals in $C_{i}$.

Example2: Assume the following CNF formula,
$$clauseMarkKorteHobe\varphi=(x)\wedge(\neg x)\wedge(\neg x\vee y)\wedge(\neg x \vee \neg y)$$
where, $x, \neg x, y$ and $\neg y$ are the literals.

The aforementioned CNF formula will ne used as an example throughout this paper which is unsatisfiable.
\subsection{Satisfiability Checking}
Satisfiability checking determines whether the existentially quantified first-order-logic formulas are satisfiable by generating solutions automatically. The formulas are Boolean combinations of theory constraints and the form of theory constraints varies depending on with which theory we want to represent first-order-logic. Some example theory constraints from different theories are given in [2].By sat solving we can check the satisfiability of formulas, though  SAT-modulo-theories (SMT) solvers are available and popular theories.

A SAT solver solves the Boolean satisfiability problem by implementing decision procedure. The DPLL algorithm is the basis for most modern SAT solvers. The input formula of it is expected to be in conjunctive normal form (CNF).

Example1: Let us consider a CNF $(x) \wedge (\neg x\vee\neg y) \wedge (z)$. First $x$ is set to $true$. Boolean constraint propagation
(BCP) indicates that  $y$ of the second clause must be $false$ to satisfy the CNF. There is still a unassigned variables. A new decision will be made and $z$ is set to $true$. As all variables are assigned and there is no conflict, the satisfying soluiton is $x=1, y=0$ and $z=1$.

SMT solvers can be applied on quantifier-free first-order-logic formulas with an underlying theory to check the satisfiability. There are two type of SMT solvers, Eager SMT solver and Lazy SMT solver. To know about SMT in details you can read [3].
\subsection{Clause-Selector Variables}
Authors of the paper [1] has used clause-selector variable by augmenting a CNF formula. Clause-selector variable is a variable $w_{i}$ which is negated to augment each clause of $C_{i}$ of a CNF such that $C^{\prime}_{i}=(\neg w_{i})\vee C_{i}$ in a new formula $\varphi^{\prime}$. Notice that each $C^{\prime}_{i}$ is an implication, $C^{\prime}_{i}=(\neg w_{i}\rightarrow C_{i})$. It menas if $w_{i}$ is set to $true$, the original clause is being enabled. Conversely, assigning $w_{i}$ $false$ means $C_{i}$ is being disabled or removed from the set of constraints, because $C^{\prime}_{i}$ is satisfied by the assignment to $w_{i}$. So, adding clause-selector variables provides the SAT solver the ability to enable and disable constraints as a part of its normal search.

For our example formula, after adding these clause-selector variables we get the following augmented formula $\varphi^{\prime}$, 
$$\varphi^{\prime}=(\neg w_{1}\vee x)\wedge(\neg w_{2}\vee \neg x)\wedge(\neg w_{3}\vee \neg x\vee y)\wedge(\neg w_{4}\vee \neg x \vee \neg y)$$
\subsection{Minimal Unsatisfiable Subset and Minimal Correction Subset }
A Minimal Unsatisfiable Subset (MUS) ia a subset of the clauses of an unsatisfiable CNF formula $\varphi$ that is both unsatisfiable and minimal. A Minimal Correction Subset (MCS) is a subset of the clauses of $\varphi$ whose removal from $\varphi$ make it satisfiable and which is minimal. A formula can have multiple MUSes and MCSes. The formal definitionss of the set of MUSes and MCSes of $\varphi$ is given following:

Definition1: A subset $U$ be a MUS which is a subset of $\varphi$ if $U$ is unsatisfiable and for each clause $C_{i}$ containing in $U$ the removal of $C_{i}$ from $U$ is satisfiable.
$$khataThekeLikhteHobe$$
Defintion2: A subset $M$ be a MCS which is a subset of $\varphi$ if the removal of $M$ from $\varphi$ is satisfiable and for each clause $C_{i}$ of $M$ the removal of $M$ from $\varphi$ is unsatisfiable where $M$ does not have $C_{i}$.
$$khataThekeLikhteHobe$$
For our example formula $\varphi=(x)\wedge(\neg x)\wedge(\neg x\vee y)\wedge(\neg x \vee \neg y)$ the MUSes and MCSes are shown in the following table:
$$tableAkteHobe$$
\subsection{Hitting Sets}
Assume a collection $\Omega$ of sets of a finite set $D$. A hitting set of $\Omega$ is a subset of $D$ such that it contains at least one element from each subset in $\Omega$. Formally, the definition is given below:

Definition3: A hitting set $H$ of $\Omega$ is $H\subseteq D$ such that $\forall S\in \Omega$, $H\cap S\neq 0$ where $S$ represents each subset of $\Omega$.

In the paper [1], authors refer to minimal hitting sets which are the hitting sets from which no elements cannot be removed and if at least one element is removed, it will not be a hitting set anymore.

Example: Let us consider, $\Omega=\{\{a, b\}, \{b, c, d\}\}$. Then, $\{a,b\}, \{b,c,d\}, \{a,c,d\}, \{b\},\cdots$ are the hitting sets where, $\{b\}$ is the only minimal hitting set.
\subsection{MUS backSlashDiteHobe MCS Duality}
There is a relationship between MUS and MCS which is the foundation of paper [1]. The relationship states that the set of MUSes of formula $\varphi$ is equal to theset of minimal and irreducible hitting sets of the set of MCSes and vice-versa. This is the duality of MUS and MCS. Fomally it can said that:

$1.$ A subset $U$ of $\varphi$ is an MUS if and only if $U$ is an irreducible hitting set of MCSes$(\varphi)$.

$2.$ A subset $M$ of $\varphi$ is an MUS if and only if $M$ is an irreducible hitting set of MUSes$(\varphi)$.

$$dualityPicAkteHobe$$

To show duality we use our example formula $\varphi=(x)\wedge(\neg x)\wedge(\neg x\vee y)\wedge(\neg x \vee \neg y)$. First, take the set MCSes of $\varphi$ and it is $\{\{C_{1}\}, \{C_{2}, C_{3}\}, \{C_{2}, C_{4}\}\}$. For this, the set of minimal and irreducible hitting sets is $\{\{C_{1}, C_{2}\}, \{C_{1}, C_{3,} C_{4}\}\}$ which is exactly like the set of MUSes (given in Table $blabla$). Similarly, we can show that the set of MCSes is the set of irreducible hitting sets of the set of MUSes. So, every MCS has at least one clause from every MUS and vice-versa. The duality is illustrated in Figure(blabla).

\subsection{AtMost Constraints}
AtMost Constraint is a type of clause that can be generated from many types of clauses. If $\{l_{1}, l_{2}, l_{3},\cdots ,l_{\text n}\}$ is a set of $n$ literals and $k$ is a positive integer, an AtMost constraint is defines as,
$$AtMosterFormulaLikhteHobe$$
where, $val(l_{\text i})$ is 1 if $l_{i}$ is assigned $true$ and otherwise 0. $k$ is a bound which tells that maximum how many literals can be assigned $true$.
Authors used an implementation of the AtMost constraint where the variables are watched and propagates the negation of each literal when $k$ of them are assigned $true$. This is implemented with exactly $n$ watched literals and a counter that is incremented or decremented whenever on of them is assigned or unassigned.



